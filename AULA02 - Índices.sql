USE bd_meli01;

-- APAGA TODA A TABELA SEM PEDIR CONFIRMAÇÃO
DROP TABLE user;

-- CRIANDO A TABELA NOVAMENTE
CREATE TABLE user(
	id INTEGER,
    nome VARCHAR(100)
);

INSERT INTO user VALUES(1, "Wonder Woman");

-- --------------- --
SELECT * FROM user;
-- --------------- --

-- ATÉ O MOMENTO, A TABELA USER NÃO TEM NENHUM ÍNDICE

-- INSERINDO ÍNDICES NA TABELA

-- ALTERA A ESTRUTURA DA TABELA USER ADICIONANDO UMA RESTRIÇÃO DE CHAVE PRIMÁRIA
ALTER TABLE user
ADD CONSTRAINT
PRIMARY KEY (id);

-- APÓS A INCLUSÃO DO ÍNDICE, TENTAR INSERIR NUM MESMO ID VAI DAR ERRO:
INSERT INTO user VALUES(1, "Mulher Maravilha");

-- INCLUINDO UMA NOVA COLUNA NA TABELA
ALTER TABLE user
ADD email VARCHAR(50);

-- ADICIONANDO A INFORMAÇÃO DO NOVO CAMPO
UPDATE user
SET email= "ww@justiceleague.com"
WHERE id = 1;

-- GERANDO DUPLICIDADE NO EMAIL, INSERINDO UM NOVO USUÁRIO COM O MESMO EMAIL
INSERT INTO user VALUES(2, "Mulher Maravilha", "ww@justiceleague.com");

-- CORRIGINDO DUPLICIDADE

-- Primeiro tem que remover as duplicidades da tabela, portanto:
UPDATE user
SET email= "mm@justiceleague.com"
WHERE id = 2;

-- E depois incluir a regra. Essa regra define que nesse campo não poderão haver repetições, mas ele pode ser null
ALTER TABLE user
ADD CONSTRAINT UNIQUE (email);

-- ÍNDICE FAZ COM QUE A CONSULTA TENHA UM DESEPENHO MELHOR, PORQUE LEVA DIRETAMENTE PRO LUGAR CERTO NA TABELA. 
-- ELE SEMPRE DEVE SER ATUALIZADO A CADA ATUALIZAÇÃO OU MODIFICAÇÃO.
-- PORTANTO TER MUITOS ÍNDICES IMPLICA EM PROBLEMAS DE PERFORMANCE.
-- SE A TABELA QUASE NÃO SOFRE ALTERAÇÕES, PODE SER BOM TER VÁRIOS ÍNDICES, POREM SE ELA SOFRE CONSTANTES ALTERAÇÕES, TER MUITOS ÍNDICES NÃO É INDICADO.
